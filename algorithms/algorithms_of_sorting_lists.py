'''
    Сортировка пузырьком - это метод сортировки массивов и списков 
путем последовательного сравнения и обмена соседних элементов, 
если предшествующий оказывается больше последующего.
    В сортировке методом пузырька количество итераций внешнего цикла определяется длинной списка минус единица, 
так как когда второй элемент становится на свое место, то первый уже однозначно минимальный и находится на своем месте.
    Количество итераций внутреннего цикла зависит от номера итерации внешнего цикла, так как конец списка уже отсортирован, 
и выполнять проход по этим элементам смысла нет.

Сортировка с помощью циклов while:
i и j - индексы
N -количество элементов в последовательности

i = 0
while i < N - 1:
    j = 0
    while j < N - 1 - i:
        if a[j] > a[j+1]:
            a[j], a[j+1] = a[j+1], a[j]
        j += 1
    i += 1

'''
# сортировка списка методом пузырька (по возврастанию)
def sort_of_list_from_min_to_max_bubble(l):
    kol_of_elements = len(l)
    # переменная kol_of_elements - количество элементов в последовательности
    for i in range(kol_of_elements - 1):
        for j in range(kol_of_elements - i - 1):
            if l[j] > l [j+1]:
                # сравниваем два соседних элемента в списке
                l[j], l[j+1] = l[j + 1], l[j]
                # если левый элемент больше правого, то меняем их местами
    return l
# сортировка списка методом пузырька (по убыванию)
def sort_of_list_from_max_to_min_bubble(l):
    kol_of_elements = len(l)
    # переменная kol_of_elements - количество элементов в последовательности
    for i in range(kol_of_elements - 1):
        for j in range(kol_of_elements - i - 1):
            if l[j] < l [j+1]:
                # сравниваем два соседних элемента в списке
                l[j + 1], l[j] = l[j], l[j+1]
                # если правый элемент больше левого, то меняем их местами
    return l
'''
Сортировка выбором заключается в поиске на необработанном срезе массива или списка
минимального значения и в дальнейшем обмене этого значения с первым элементом необработанного среза.
На следующем шаге необработанный срез уменьшается на один элемент.
1. Найти наименьшее значение в списке.
2. Записать его в начало списка, а первый элемент - на место, где стоял наименьший.
3. Снова найти наименьший элемент в списке. При этом в списке не участвует первый элемент.
4. Второй минимум поместить на второе место списка. Второй элемент при этом перемещается на освободившееся место.
5. Продолжить выполнять поиск и обмен, пока не будет достигнут конец списка.

В цикле переменная i хранит индекс ячейки, в которую записывается минимальный элемент.
Сначала это будет первая ячейка.
i = 0

N - 1, так как последний элемент обменивать уже не надо.

while i < N - 1:

ПОИСК МИНИМУМА
Сначала надо найти минимальное значение на срезе от i до конца списка.
Переменная m будет хранить индекс ячейки с минимальным значением.
Сначала предполагаем, что в ячейке i содержится минимальный элемент.

m = i

Поиск начинаем с ячейки следующей за i.

j = i + 1

Пока не дойдем до конца списка,

while j < N:

удем сравнивать значение ячейки j, со значением ячейки m.

if arr[j] < arr[m]:

Если в j значение меньше, чем в m, сохраним в m номер найденного на данный момент минимума.

m = j

Перейдем к следующей ячейке.

j += 1

ОБМЕН ЗНАЧЕНИЙ
В ячейку i записывается найденный минимум, а значение из ячейки i переносится на старое место минимума.

arr[i], arr[m] = arr[m], arr[i]

ПЕРЕХОД К СЛЕДУЮЩЕЙ НЕОБРАБОТАННОЙ ЯЧЕЙКЕ

i += 1

'''
# сортировка списка методом выбора (по возврастанию)
def sort_of_list_from_min_to_max_choose(l):
    kol_of_elements = len(l)
    # переменная kol_of_elements - количество элементов в последовательности
    for i in range(kol_of_elements - 1):
        m = i
        j = i + 1
        while j < kol_of_elements:
            if l[j] < l[m]:
                m = j
            j += 1
            l[i], l[m] = l[m], l[i]
    return l
# сортировка списка методом выбора (по убыванию)
def sort_of_list_from_max_to_min_choose(l):
    kol_of_elements = len(l)
    # переменная kol_of_elements - количество элементов в последовательности
    for i in range(kol_of_elements - 1):
        m = i
        j = i + 1
        while j < kol_of_elements:
            if l[j] > l[m]:
                m = j
            j += 1
            l[m], l[i] = l[i], l[m]
    return l



N = int(input('Введите количество элементов последовательности: '))
l = []
for i in range(N - 1):
    l.append(input('Введите число последовательности: '))
print('Вы ввели следующую последовательность: ', l)
print('Эта же последовательность, только отсортированная по возврастанию:', sort_of_list_from_min_to_max_bubble(l))
print('Эта же последовательность, только отсортированная по убыванию:', sort_of_list_from_max_to_min_bubble(l))
print('Эта же последовательность, только отсортированная по возврастанию:', sort_of_list_from_min_to_max_choose(l))
print('Эта же последовательность, только отсортированная по убыванию:', sort_of_list_from_max_to_min_choose(l))